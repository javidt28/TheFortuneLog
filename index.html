<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TheFortuneLog - Track Your Fortune Cookie Fortunes</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Firebase Config (update with your credentials) -->
    <script src="firebase-config.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="root"></div>
    
    <script>
        // Animated Fortune Cookie Background
        (function() {
            var canvas = document.querySelector("#canvas");
            if (!canvas) return;
            
            var context = canvas.getContext("2d");
            var numShapes = 25;
            var shapes = [];
            var tau = Math.PI * 2;
            var vw = 0;
            var vh = 0;
            
            // Fortune cookie shapes as simplified paths
            var cookieShapes = [
                // Shape 1 - Crescent
                function(ctx, x, y, scale) {
                    ctx.beginPath();
                    ctx.arc(x, y, 40 * scale, 0.3 * Math.PI, 1.7 * Math.PI);
                    ctx.arc(x + 20 * scale, y, 30 * scale, 1.7 * Math.PI, 0.3 * Math.PI, true);
                    ctx.closePath();
                },
                // Shape 2 - Open cookie
                function(ctx, x, y, scale) {
                    ctx.beginPath();
                    ctx.arc(x, y, 45 * scale, 0.2 * Math.PI, 1.8 * Math.PI);
                    ctx.arc(x + 25 * scale, y, 35 * scale, 1.8 * Math.PI, 0.2 * Math.PI, true);
                    ctx.closePath();
                },
                // Shape 3 - Side view
                function(ctx, x, y, scale) {
                    ctx.beginPath();
                    ctx.ellipse(x, y, 50 * scale, 30 * scale, 0.3, 0, tau);
                    ctx.closePath();
                },
                // Shape 4 - Narrow crescent
                function(ctx, x, y, scale) {
                    ctx.beginPath();
                    ctx.arc(x, y, 35 * scale, 0.4 * Math.PI, 1.6 * Math.PI);
                    ctx.arc(x + 15 * scale, y, 25 * scale, 1.6 * Math.PI, 0.4 * Math.PI, true);
                    ctx.closePath();
                },
                // Shape 5 - Wide open
                function(ctx, x, y, scale) {
                    ctx.beginPath();
                    ctx.arc(x, y, 42 * scale, 0.1 * Math.PI, 1.9 * Math.PI);
                    ctx.arc(x + 30 * scale, y, 38 * scale, 1.9 * Math.PI, 0.1 * Math.PI, true);
                    ctx.closePath();
                }
            ];
            
            function random(min, max) {
                return Math.random() * (max - min) + min;
            }
            
            function createShape() {
                return {
                    x: random(-100, vw + 100),
                    y: random(-100, vh + 100),
                    vx: random(-0.8, 0.8),
                    vy: random(-0.8, 0.8),
                    angle: random(0, tau),
                    rotationSpeed: random(-0.03, 0.03),
                    scale: random(0.4, 1.0),
                    shapeIndex: Math.floor(random(0, cookieShapes.length)),
                    hue: random(120, 160),
                    saturation: random(50, 70),
                    lightness: random(40, 60),
                    opacity: random(0.3, 0.5),
                    shapeChangeTimer: random(80, 150)
                };
            }
            
            function resize() {
                vw = canvas.width = window.innerWidth;
                vh = canvas.height = window.innerHeight;
            }
            
            function init() {
                resize();
                shapes = [];
                for (var i = 0; i < numShapes; i++) {
                    shapes.push(createShape());
                }
            }
            
            function update() {
                for (var i = 0; i < shapes.length; i++) {
                    var shape = shapes[i];
                    
                    // Update position
                    shape.x += shape.vx;
                    shape.y += shape.vy;
                    shape.angle += shape.rotationSpeed;
                    
                    // Change shape periodically
                    shape.shapeChangeTimer--;
                    if (shape.shapeChangeTimer <= 0) {
                        shape.shapeIndex = Math.floor(random(0, cookieShapes.length));
                        shape.shapeChangeTimer = random(100, 200);
                    }
                    
                    // Wrap around edges
                    if (shape.x < -150) shape.x = vw + 150;
                    if (shape.x > vw + 150) shape.x = -150;
                    if (shape.y < -150) shape.y = vh + 150;
                    if (shape.y > vh + 150) shape.y = -150;
                }
            }
            
            function render() {
                context.clearRect(0, 0, vw, vh);
                context.globalCompositeOperation = "screen";
                
                for (var i = 0; i < shapes.length; i++) {
                    var shape = shapes[i];
                    var shapeFunc = cookieShapes[shape.shapeIndex];
                    
                    context.save();
                    context.translate(shape.x, shape.y);
                    context.rotate(shape.angle);
                    
                    // Draw cookie shape
                    shapeFunc(context, 0, 0, shape.scale);
                    
                    // Fill with green color
                    context.fillStyle = `hsla(${shape.hue}, ${shape.saturation}%, ${shape.lightness}%, ${shape.opacity})`;
                    context.fill();
                    
                    // Add subtle stroke
                    context.strokeStyle = `hsla(${shape.hue}, ${shape.saturation}%, ${shape.lightness + 10}%, ${shape.opacity * 0.8})`;
                    context.lineWidth = 1.5;
                    context.stroke();
                    
                    context.restore();
                }
            }
            
            function animate() {
                update();
                render();
                requestAnimationFrame(animate);
            }
            
            init();
            animate();
            window.addEventListener("resize", init);
        })();
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Name Modal Component
        function NameModal({ onConfirm, onSkip }) {
            const [name, setName] = useState('');
            const [isSubmitting, setIsSubmitting] = useState(false);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (name.trim()) {
                    setIsSubmitting(true);
                    onConfirm(name.trim());
                }
            };

            return (
                <div className="name-modal-overlay">
                    <div className="name-modal">
                        <div className="name-modal-header">
                            <h2 className="name-modal-title">Welcome to TheFortuneLog!</h2>
                            <p className="name-modal-subtitle">Enter your name to personalize your fortunes</p>
                        </div>
                        <form onSubmit={handleSubmit} className="name-modal-form">
                            <input
                                type="text"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                placeholder="Your name..."
                                className="name-input"
                                autoFocus
                                maxLength={50}
                            />
                            <div className="name-modal-actions">
                                <button
                                    type="button"
                                    onClick={onSkip}
                                    className="btn btn-secondary name-skip-btn"
                                >
                                    Skip
                                </button>
                                <button
                                    type="submit"
                                    className="btn btn-primary name-submit-btn"
                                    disabled={!name.trim() || isSubmitting}
                                >
                                    Continue
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        // Toast Notification Component
        function Toast({ message, onClose }) {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onClose();
                }, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);

            return (
                <div className="toast">
                    <span>{message}</span>
                    <button onClick={onClose} className="toast-close">Ã—</button>
                </div>
            );
        }

        // Fortune Card Component
        function FortuneCard({ fortune, duplicateCount, index }) {
            const date = new Date(fortune.date);
            const formattedDate = date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
            });

            return (
                <div 
                    className={`fortune-card ${duplicateCount > 1 ? 'duplicate' : ''}`}
                >
                    {duplicateCount > 1 && (
                        <div className="duplicate-badge">
                            <span className="duplicate-icon">ðŸ”„</span>
                            <span className="duplicate-text">Ã—{duplicateCount}</span>
                        </div>
                    )}
                    <div className="fortune-card-content">
                        <div className="fortune-text-wrapper">
                            <div className="fortune-text">{fortune.text}</div>
                        </div>
                        <div className="fortune-footer">
                            <div className="fortune-meta">
                                <div className="fortune-date">
                                    <span>{formattedDate}</span>
                                </div>
                                {fortune.author && (
                                    <div className="fortune-author">
                                        <span className="author-label">by</span>
                                        <span className="author-name">{fortune.author}</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Fortune Form Component (Modal)
        function FortuneForm({ onAdd, onClose }) {
            const [text, setText] = useState('');
            const [isSubmitting, setIsSubmitting] = useState(false);
            const textareaRef = React.useRef(null);

            React.useEffect(() => {
                if (textareaRef.current) {
                    textareaRef.current.focus();
                }
            }, []);

            const handleSubmit = (e) => {
                e.preventDefault();
                const trimmedText = text.trim();
                if (!trimmedText || isSubmitting) return;

                setIsSubmitting(true);
                onAdd(trimmedText);
                setText('');
                setTimeout(() => {
                    setIsSubmitting(false);
                    onClose();
                }, 300);
            };

            const handleKeyDown = (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    handleSubmit(e);
                }
                if (e.key === 'Escape') {
                    onClose();
                }
            };

            return (
                <div className="add-fortune-modal" onClick={onClose}>
                    <div className="add-fortune-modal-content" onClick={(e) => e.stopPropagation()}>
                        <div className="modal-header">
                            <h2>Add Fortune</h2>
                            <button className="modal-close" onClick={onClose}>Ã—</button>
                        </div>
                        <form onSubmit={handleSubmit} className="fortune-form">
                            <textarea
                                ref={textareaRef}
                                value={text}
                                onChange={(e) => setText(e.target.value)}
                                onKeyDown={handleKeyDown}
                                placeholder="Enter your fortune cookie message..."
                                rows="4"
                                className="fortune-textarea"
                                required
                            />
                            <div className="form-footer">
                                <button 
                                    type="button"
                                    className="btn btn-secondary"
                                    onClick={onClose}
                                >
                                    Cancel
                                </button>
                                <button 
                                    type="submit" 
                                    className={`btn btn-primary ${isSubmitting ? 'submitting' : ''}`}
                                    disabled={isSubmitting || !text.trim()}
                                >
                                    {isSubmitting ? 'Adding...' : 'Add Fortune'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        // Main App Component
        function App() {
            const [fortunes, setFortunes] = useState([]);
            const [toast, setToast] = useState(null);
            const [showNameModal, setShowNameModal] = useState(false);
            const [showAddModal, setShowAddModal] = useState(false);
            const [isInitialized, setIsInitialized] = useState(false);
            const [userName, setUserName] = useState(() => {
                return localStorage.getItem('fortuneUserName') || '';
            });

            // Initialize Firebase sync on mount
            useEffect(() => {
                let unsubscribe = null;

                const initializeFirebaseSync = async () => {
                    // Check if Firebase is available and configured
                    if (typeof firebase === 'undefined' || !isFirebaseReady || !db) {
                        showToast('Firebase not configured. Please check firebase-config.js');
                        setIsInitialized(true);
                        return;
                    }

                    try {
                        // Use shared collection for all fortunes (no user-specific path)
                        const fortunesRef = db.collection('fortunes');
                        
                        // Set up real-time listener for changes
                        unsubscribe = fortunesRef.onSnapshot((snapshot) => {
                            const cloudFortunes = snapshot.docs.map(doc => ({
                                id: doc.id,
                                text: doc.data().text,
                                date: doc.data().date,
                                author: doc.data().author || null
                            }));
                            setFortunes(cloudFortunes);
                            setIsInitialized(true);
                        }, (error) => {
                            console.error('Firebase sync error:', error);
                            showToast('Error syncing with Firebase');
                            setIsInitialized(true);
                        });
                    } catch (error) {
                        console.error('Firebase initialization error:', error);
                        showToast('Failed to connect to Firebase');
                        setIsInitialized(true);
                    }
                };

                initializeFirebaseSync();

                // Cleanup function
                return () => {
                    if (unsubscribe) {
                        unsubscribe();
                    }
                };
            }, []);

            const saveToFirebase = async (fortunesArray) => {
                if (!db) {
                    console.error('Firebase not ready:', { db: !!db });
                    return;
                }
                
                try {
                    // Use shared collection for all fortunes
                    const fortunesRef = db.collection('fortunes');
                    const batch = db.batch();
                    
                    // Clear existing
                    const snapshot = await fortunesRef.get();
                    snapshot.docs.forEach(doc => batch.delete(doc.ref));
                    
                    // Add all fortunes
                    fortunesArray.forEach(fortune => {
                        const docRef = fortunesRef.doc(String(fortune.id));
                        batch.set(docRef, {
                            text: fortune.text,
                            date: fortune.date,
                            author: fortune.author || null
                        });
                    });
                    
                    await batch.commit();
                    console.log('Successfully saved', fortunesArray.length, 'fortunes to Firebase');
                } catch (error) {
                    console.error('Error saving to Firebase:', error);
                    console.error('Error details:', {
                        code: error.code,
                        message: error.message
                    });
                    showToast(`Error saving to Firebase: ${error.message}`);
                }
            };

            const showToast = (message) => {
                setToast(message);
            };

            const handleNameConfirm = (name) => {
                setUserName(name);
                localStorage.setItem('fortuneUserName', name);
                localStorage.setItem('fortuneUserNameSet', 'true');
                setShowNameModal(false);
                showToast(`Welcome, ${name}! ðŸŽ‰`);
            };

            const handleNameSkip = () => {
                localStorage.setItem('fortuneUserNameSet', 'true');
                setShowNameModal(false);
            };

            const addFortune = async (text) => {
                // Ensure text ends with a period
                let formattedText = text.toUpperCase().trim();
                if (formattedText && !formattedText.match(/[.!?]$/)) {
                    formattedText += '.';
                }
                
                const newFortune = {
                    id: Date.now().toString(),
                    text: formattedText,
                    date: new Date().toISOString(),
                    author: userName || null
                };
                
                const updatedFortunes = [...fortunes, newFortune];
                setFortunes(updatedFortunes);
                showToast('Fortune added successfully!');
                
                // Sync to Firebase
                try {
                    await saveToFirebase(updatedFortunes);
                } catch (error) {
                    console.error('Failed to save fortune:', error);
                    showToast('Fortune added locally but failed to sync');
                }
            };

            const deleteFortune = async (id) => {
                const updatedFortunes = fortunes.filter(f => f.id !== id);
                setFortunes(updatedFortunes);
                showToast('Fortune deleted');
                
                // Sync to Firebase
                await saveToFirebase(updatedFortunes);
            };

            const exportFortunes = () => {
                const dataStr = JSON.stringify(fortunes, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `fortunes-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showToast('Fortunes exported successfully!');
            };

            const importFortunes = async (file) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (Array.isArray(imported)) {
                            const existingIds = new Set(fortunes.map(f => f.id));
                            const newFortunes = imported
                                .filter(f => !existingIds.has(String(f.id)))
                                .map(f => ({
                                    ...f,
                                    text: (() => {
                                        let text = f.text.toUpperCase().trim();
                                        if (text && !text.match(/[.!?]$/)) {
                                            text += '.';
                                        }
                                        return text;
                                    })(),
                                    author: f.author || userName || null
                                }));

                            if (newFortunes.length > 0) {
                                const updatedFortunes = [...fortunes, ...newFortunes];
                                setFortunes(updatedFortunes);
                                showToast(`Imported ${newFortunes.length} fortune(s)!`);
                                
                                // Sync to Firebase
                                await saveToFirebase(updatedFortunes);
                            } else {
                                showToast('No new fortunes to import');
                            }
                        } else {
                            throw new Error('Invalid format');
                        }
                    } catch (error) {
                        showToast('Error importing file. Please check the format.');
                    }
                };
                reader.readAsText(file);
            };

            if (!isInitialized) {
                return (
                    <div className="app">
                        <header className="app-header">
                            <div className="header-content">
                                <h1 className="app-title">
                                    TheFortuneLog
                                </h1>
                                <p className="app-subtitle">Loading...</p>
                            </div>
                        </header>
                        <div className="container" style={{ textAlign: 'center', padding: '50px', color: 'white' }}>
                            <p>Connecting to Firebase...</p>
                        </div>
                    </div>
                );
            }

            const getFortuneOfTheDay = () => {
                if (fortunes.length === 0) return null;
                
                // Use today's date as a seed for consistent selection
                const today = new Date();
                const dateString = today.toISOString().split('T')[0]; // YYYY-MM-DD
                const seed = dateString.split('-').join(''); // Convert to number
                
                // Use seed to select a fortune (deterministic based on date)
                const index = parseInt(seed) % fortunes.length;
                return fortunes[index];
            };

            const fortuneOfTheDay = getFortuneOfTheDay();

            return (
                <>
                    {showNameModal && (
                        <NameModal
                            onConfirm={handleNameConfirm}
                            onSkip={handleNameSkip}
                        />
                    )}
                    {showAddModal && (
                        <FortuneForm
                            onAdd={addFortune}
                            onClose={() => setShowAddModal(false)}
                        />
                    )}
                <div className="app">
                    <header className="app-header">
                        <div className="header-content">
                            <div>
                                <h1 className="app-title">TheFortuneLog</h1>
                            </div>
                        </div>
                    </header>

                    <div className="main-content">
                        {fortuneOfTheDay && (
                            <div className="fortune-of-the-day">
                                <div className="fortune-of-the-day-label">Fortune of the Day</div>
                                <div className="fortune-of-the-day-text">{fortuneOfTheDay.text}</div>
                            </div>
                        )}
                        
                        <div className="fortunes-header">
                            <h2>Fortunes</h2>
                            <div className="fortunes-count">{fortunes.length} fortune{fortunes.length !== 1 ? 's' : ''}</div>
                        </div>

                        {fortunes.length === 0 ? (
                            <div className="empty-state">
                                <div className="empty-icon">âœ¨</div>
                                <div className="empty-text">No fortunes yet. Add the first one!</div>
                            </div>
                        ) : (
                            <div className="fortunes-grid">
                                {fortunes.map((fortune, index) => {
                                    const duplicateCounts = {};
                                    fortunes.forEach(f => {
                                        const text = f.text.toLowerCase().trim();
                                        duplicateCounts[text] = (duplicateCounts[text] || 0) + 1;
                                    });
                                    const duplicateCount = duplicateCounts[fortune.text.toLowerCase().trim()] || 1;
                                    return (
                                        <FortuneCard
                                            key={fortune.id}
                                            fortune={fortune}
                                            duplicateCount={duplicateCount}
                                            index={index}
                                        />
                                    );
                                })}
                            </div>
                        )}
                    </div>

                    {/* Floating Add Button */}
                    <button 
                        className="add-button"
                        onClick={() => setShowAddModal(true)}
                        aria-label="Add Fortune"
                    >
                        <span className="add-button-icon">+</span>
                    </button>

                    {toast && (
                        <Toast
                            message={toast}
                            onClose={() => setToast(null)}
                        />
                    )}
                </div>
                </>
            );
        }

        // Render the app
        const rootElement = document.getElementById("root");
        if (rootElement) {
            try {
                if (ReactDOM.createRoot) {
                    const root = ReactDOM.createRoot(rootElement);
                    root.render(<App />);
                } else {
                    ReactDOM.render(<App />, rootElement);
                }
            } catch (error) {
                console.error('Error rendering app:', error);
                rootElement.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: white;">
                        <h2>Error Loading App</h2>
                        <p>${error.message}</p>
                        <p style="font-size: 12px; margin-top: 20px;">Check the browser console for details.</p>
                    </div>
                `;
            }
        } else {
            console.error('Root element not found!');
        }
